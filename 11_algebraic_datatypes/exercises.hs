module PhoneWriter
  ( parseText -- parse a text into a PhoneValue representation
  , writeText -- write a text based on it's PhoneValue representation
  , writeLiteralText -- write a sequence of button presses for a text
  ) where

import Data.List (elemIndex, intercalate)

{-
Phone layout

(1)      | (2) ABC | (3) DEF
(4) GHI  | (5) JKL | (6) MNO
(7) PQRS | (8) TUV | (9) WXYZ
(*) ^    | (0) + _ | (#) .,

-}

-- test data
convo :: [String]
convo =
  [ "wanna play 20 questions",
    "ya",
    "u 1st haha",
    "lol ok. have u ever tasted alcohol lol",
    "lol ya",
    "wow ur cool haha. ur turn",
    "ok. do u think i am pretty lol",
    "lol ya",
    "haha thanks just making sure rofl ur turn"
  ]

type Button = Char -- 1,2,3,4,5,6,7,8,9,*,0,#
type Presses = Int
type Series = [Char] -- abc, def, ghi ...
type LookupTable = [(Button,Series)] -- ('5', "jkl")

-- A PhoneValue is a button and how many times it is pressed
data PhoneValue = PhoneValue Button Presses deriving (Eq, Ord, Show)

-- association between buttons and their values
lookupTable :: LookupTable
lookupTable =
  [ ('1', "1") -- only number 1
  , ('2', "abc2")
  , ('3', "def3")
  , ('4', "ghi4")
  , ('5', "jkl5")
  , ('6', "mno6")
  , ('7', "pqrs7")
  , ('8', "tuv8")
  , ('9', "wxyz9")
  , ('*', "^*") -- capitalization, currently not implemented/supported
  , ('0', " 0") -- space bar and number 0
  , ('#', ".,#")
  ]

-- returns the series corresponding to a button
seriesFromButton :: Button -> Series
seriesFromButton button =
  let element = filter (\(k,_) -> k == button) lookupTable
  in snd $ head element

-- returns the button responsible for a character
buttonFromChar :: Char -> Button
buttonFromChar c =
  let element = filter (\(_,v) -> elem c v) lookupTable
  in fst $ head element

-- returns the character generated by pressing a button n times
charFromPresses :: Presses -> Button -> Char
charFromPresses presses button =
  let l = length series
      series = seriesFromButton button
  in  series !! ((presses - 1) `mod` l)

-- calculates how many presses are needed to get a particular character
pressesForChar :: Char -> Presses
pressesForChar c =
  let button = buttonFromChar c
      Just index = elemIndex c (seriesFromButton button)
  in index + 1

-- calculates the PhoneValue for a particular character
parseChar :: Char -> PhoneValue
parseChar c =
  let button = buttonFromChar c
      presses = pressesForChar c
  in PhoneValue button presses

-- parses a text into a list of PhoneValues
parseText :: String -> [PhoneValue]
parseText = map parseChar

-- writes a text based on a list of phone values
writeText :: [PhoneValue] -> String
writeText = map writePhoneValue

-- writes a PhoneValue as character
writePhoneValue :: PhoneValue -> Char
writePhoneValue (PhoneValue button presses) = charFromPresses presses button

-- writes a PhoneValue as sequence of button presses
writeLiteralPhoneValue :: PhoneValue -> String
writeLiteralPhoneValue (PhoneValue button presses) = replicate presses button

-- writes the sequences to type into the phone for a text
writeLiteralText :: [PhoneValue] -> String
writeLiteralText xs = intercalate " " $ map writeLiteralPhoneValue xs


-- Tests
parsedConvos :: [[PhoneValue]]
parsedConvos = map parseText convo

literalFirstConvo :: String
literalFirstConvo = writeLiteralText $ head parsedConvos

writtenFirstConvo :: String
writtenFirstConvo = writeText $ head parsedConvos

main :: IO ()
main = do
  putStrLn literalFirstConvo
  putStrLn writtenFirstConvo
